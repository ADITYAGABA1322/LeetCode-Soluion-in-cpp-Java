95. Unique Binary Search Trees II


9 August 2023


Medium


C++:

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        if(n==0){ // if n is equal to 0
            return {}; // return empty vector
        }
        return generateTrees(1, n); // call the generateTrees function
    }
    vector<TreeNode*> generateTrees(int start, int end){
        vector<TreeNode*> trees; // vector to store the result
        if(start > end){ // if start is greater than end
            trees.push_back(NULL); // push the null in the vector trees
            return trees; // return the vector trees
        }
        for(int i=start; i<=end; i++){ // loop for i
            vector<TreeNode*> leftTrees = generateTrees(start, i-1); // vector to store the leftTrees
            vector<TreeNode*> rightTrees = generateTrees(i+1, end); // vector to store the rightTrees
            for(auto leftTree: leftTrees){ // loop for leftTreeT
                for(auto rightTree: rightTrees){ // loop for rightTree
                    TreeNode* root = new TreeNode(i); // create the root
                    root->left = leftTree; // update the left
                    root->right = rightTree; // update the right
                    trees.push_back(root); // push the root in the vector trees
                }
            }
        }
        return trees; // return the vector trees
    }
};


Java:
// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

class Solution {
    public List<TreeNode> generateTrees(int n) {
        if(n==0){ // if n is equal to 0
            return new ArrayList<TreeNode>(); // return empty vector
        }
        return generateTrees(1, n); // call the generateTrees function
    }
    public List<TreeNode> generateTrees(int start, int end){
        List<TreeNode> trees = new ArrayList<>(); // vector to store the result
        if(start > end){ // if start is greater than end
            trees.add(null); // push the null in the vector trees
            return trees; // return the vector trees
        }
        for(int i=start; i<=end; i++){ // loop for i
            List<TreeNode> leftTrees = generateTrees(start, i-1); // vector to store the leftTrees
            List<TreeNode> rightTrees = generateTrees(i+1, end); // vector to store the rightTrees
            for(TreeNode leftTree: leftTrees){ // loop for leftTreeT
                for(TreeNode rightTree: rightTrees){ // loop for rightTree
                    TreeNode root = new TreeNode(i); // create the root
                    root.left = leftTree; // update the left
                    root.right = rightTree; // update the right
                    trees.add(root); // push the root in the vector trees
                }
            }
        }
        return trees; // return the vector trees
    }
}


Python:

// Time Complexity : O(n^2) where n is the size of the vector matrix and space complexity is O(n)

class Solution(object):
    def generateTrees(self, n):
        """
        :type n: int
        :rtype: List[TreeNode]
        """ 
        if n == 0:  # if n is equal to 0
            return []  # return empty vector
        return self.generateTreesHelper(1, n)  # call the generateTrees function
    def generateTreesHelper(self, start, end):
        trees = []  # vector to store the result
        if start > end:  # if start is greater than end
            trees.append(None)  # push the null in the vector trees
            return trees  # return the vector trees
        for i in range(start, end + 1):  # loop for i
            leftTrees = self.generateTreesHelper(start, i - 1)  # vector to store the leftTrees
            rightTrees = self.generateTreesHelper(i + 1, end)  # vector to store the rightTrees
            for leftTree in leftTrees:  # loop for leftTreeT
                for rightTree in rightTrees:  # loop for rightTree
                    root = TreeNode(i)  # create the root
                    root.left = leftTree  # update the left
                    root.right = rightTree  # update the right
                    trees.append(root)  # push the root in the vector trees
        return trees  # return the vector trees



Python3:




C:



C#



JavaScript:




Swift:




Dart:
